-------2/2 crpyto------

Block Cipher Mode

ECB: electronize codeblock mode
		m1    m2   m3 ... mn
		____________________
		|___|____|____|____|  Ci = Enc(mi;k) 
		128   128  128  128
		encryt each block

		NEVER USE ECB MODE! The result is similar to the orginal 

 CBC: Cipher Block chaining
	   Ci = Enc(mi XOR Ci-1; l)
 	   Initiation vector: C0 = random string of bits (this is needed if we send multiple messages)


 CTR: Counter mode

 	  Ki  = Enc (n, i ;k)       
 	  			-->n: number used once, i is total blocks (n can be acheievd throught counter, random, and clock)
 	  				tradeoffs of the three methods since they are not perdictable.
 	  				java.secruity.secure.random (use this)
 	  after create sub key of ki
 	  Ci= mi XOR Ki


 	  PKCS5 Padding: Let B be the number of bytes that need to be added to the final plaintext partial block


 	  Pad with B coies of the byte representing the integer B


Shared Key crpyto: Symnetric crypto DES, AES
Public key crpyto: Asymmetric:   RSA, EIGamol
				Public Key K, Privates key k;

				public key encryption (Alice send to Bob maintain confentiality)
				0. Bob(Kb, Kb) = Gen(len)
				1. Alice : c= Enc(m; Kb)
				2. Alice sent to Bob : C
				3. Bob : m = Dec(c; Kb)

Hybrid Encrption

				0. Bob:(Kb, Kb) = Gen_asy(len)
				1. Alice:Ks = Gens(len)  session key
						 c1= 	EncA(Ks;Kb)
						 c2 =   EncS(ml Ks)   mode

				2. Alice--> Bob: C1, C2
				3. Bob: Ks = DecA(c1; Kb)
						m=Decs(Cs; Ks)

